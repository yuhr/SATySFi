% -*- coding: utf-8 -*-

\document(|
  title = {Macrodown \version; 解説};
  author = {Takshi SUWA};

  lang = `ja`;

  html-style-sheet = `./intr_style.css`;

  latex-class-file = `jsarticle`;
  latex-packages = [
    (`amsmath`, []);
    (`amssymb`, []);
    (`fontenc`, [`T1`]);
    (`lmodern`, []);
    (`graphicx`, [`dvipdfmx`]);
    (`xcolor`, [`dvipdfmx`]);
    (`tikz`, []);
    (`eclbkbox`, []);

    (`gfncls`, []);
    (`mdframed`, []);
  ];
  latex-additional-settings = {
    \\setsectiontheme\{strongline\}
    \\setlength\\parskip\{1zw\}
    \\mdfdefinestyle\{codebox\}\{\deeper{
      frametitlerule=true,
      frametitlefont=\\normalfont,
      frametitlebackgroundcolor=gray!20,
      linewidth=1pt
    }\}
  };
|){
  \maketitle;
  \section{概要}{
    \p{
      \newword{Macrodown}（\newword{マクロダウン}）は
      「マークアップの記述においてはマークアップ方法自体もユーザが設計できるべきである」
      という思想のもとに制作された，
      \LaTeX;やHTMLなどのマークアップ言語をラップするための軽量［要出典］マークアップ言語です。
      OCamlで実装しており，ソースコードは
      
      \url-display{http://github.com/gfngfn/Macrodown}
      
      で公開しています。この文書もMacrodownを経由してHTMLソースコードと\LaTeX;ソースコードを出力し，
      \LaTeX;ソースコードの方は\pLaTeX2e;とdvipdfmxで組んでいます。
    }
  }
  \section{動機}{
    \p{
      今日，一般的な文書作成のために多用されているマークアップ言語としては
      HTML+CSSや\LaTeX;などが挙げられます。
      しかし，このHTML+CSSと\LaTeX;は一長一短です。
    }
    \p{
      HTML+CSSは構造と体裁がよく分離されており，CSSによる体裁の変更等も柔軟ですが，
      記法が冗長で，またマクロ定義機能も存在していない\footnote{おそらく意図的に取り入れられていないのでしょう。}ため，
      直接人間の手で文書を記述するには適しているとは思えません。
      Markdown，AsciiDoc，その他ローカルなWiki記法など，HTMLを専用にラップする軽量マークアップ言語も数多くありますが，
      用途が限られている傾向にあり，表現力は乏しいと言わざるを得ないでしょう。
    }
    \p{
      一方の\LaTeX;は比較的平易な記法でマクロ定義機能が備わっており，先達による高度なパッケージも充実し，
      そして何よりもソフトウェアとしての\TeX;が高品質な組版結果を出力してくれますが，
      構造と体裁が明示的に分離されていないため体裁を扱うには或る程度のリテラシーが必要であったり，
      柔軟なマクロを創るには\TeX; on \LaTeX;の知識が必要で，これが相当非直感的な仕様であるため，
      大多数の人を寄せつけない様相を呈しています。
    }
    \p{
      これらの欠点を解決し，またWebページとPDFを共通の規格で記述できるようにすべく，
      Macrodownの制作に手をつけました。
      記法は“OCamlと\LaTeX;のハーフ”であり，
      “意味論が綺麗な\LaTeX;的記法”を目指したといってもよいかもしれません。
    }
  }
  \section{実用的な例}{
    \subsection{クラス名・ID名オプション}{
      \p{
        クラス名・ID名オプション機能を使うと，
        例えば

        \mcrd-display```
          \div{The quick brown fox jumps over the lazy dog.}
          \div .quote {色は匂へど散りぬるを，吾が世誰ぞ恒ならむ。}
          \div .quote #tori {鳥啼く声す，夢覚ませ。見よ明け亘る，東を。}
        ```

        から

        \mcrd-display```
          <div>
            The quick brown fox jumps over the lazy dog.
          </div>
          <div class="quote">
            色は匂へど散りぬるを，吾が世誰ぞ恒ならむ。
          </div>
          <div class="quote" id="tori">
            鳥啼く声す，夢覚ませ。見よ明け亘る，東を。
          </div>
        ```
            %有為の奥山今日越えて，浅き夢見じ，酔いもせず。
            %空色映えて，沖つ辺に，帆船群れゐぬ，靄の内。

        を得るようなマクロ \mcrd`\div` を定義することができます。
        クラス名・ID名オプション機能はHTMLの影響で実装したものですが，
        HTMLに限らず「マークアップ上大きな意味はないが小さい分岐をさせたいとき」に利用できます。
        函数・マクロ定義の項目で後述します。
      }
    }
    \subsection{自動番号づけ・相互参照}{
      \p{
        Macrodownには強力な相互参照を実装できる機能があり，例えば
        
        \mcrd-display```
          \section{はじめに}{
            \p{後方参照の例です。\ref{next}の番号を前方で取得できます。}
          }
          \section #next {サンプル}{
            \p{参照される側にはIDをつけておけばOK!}
          }
        ```

        に対する出力として

        \mcrd-display```
          <section>
            <h1>第1章 はじめに</h1>
              <p>
                後方参照の例です。第2章の番号を前方で取得できます。
              </p>
            <!-- ---- ---- ---- ---- -->
          </section>
          <section id="next">
            <h1>第2章 サンプル</h1>
              <p>
                参照される側にはIDをつけておけばOK!
              </p>
            <!-- ---- ---- ---- ---- -->
          </section>
        ```

        を得るようなマクロ \mcrd`\section`，\mcrd`\ref` を定義することが可能です。
        \LaTeX;ではこのような相互参照は更新するたびに2回タイプセットしなければ正当に出力されませんが，
        Macrodownのテキスト整形では1度で正当な相互参照を出力することができます。
      }
    }
  }
  \section{言語仕様}{
    \subsection{階層}{
      \p{
        Macrodownでは構文に階層という概念があり，
        \newword{テキスト階層}，\newword{プログラム階層}，\newword{アクティヴ階層}，
        \newword{リテラル階層}，\newword{コメント階層}の5種類が区別されます。
        このうちコメント階層は単にコメントアウトの範囲を指し，
        コード上にある文字\mcrd`%`からその行の行末の改行文字までをコメントとみなします。
        またリテラル階層はテキスト階層の“仲間”であり，扱いの上では特にテキスト階層と大きな差異がありません。
        アクティヴ階層はテキスト階層中で引数に\newword{適用}された制御綴の直後に現れる，（多くの場合）小さい範囲です。
        これについてはマクロの適用と同時に解説します。
        以上の3種類は附加的であり，Macrodownを書くときは主にテキスト階層とプログラム階層の2種類を強く意識することになります。
        テキスト階層は文書の記述本体を担い，構文は\LaTeX;やMarkdownと類似しています。
        プログラム階層は函数とマクロの定義を担い，構文はML系言語に近いものです。
      }
    }
    \subsection{入出力方法}{
      \p{
        まずはどのようにソースコードを与え，どのように出力を得るかを見てみましょう。
        お決まりのHello World!を出力するソースコードを書いてみます。
        
        \mcrd-input`input.mcrd` ```
          Hello World!
        ```
        
        一般的なプログラミング言語でHello World!を書いた人なら「冗談だろう」と思われることでしょう。
        世界で最もつまらないHello World!であることは疑う餘地なしです。これに対して
        
        \mcrd-display```
          macrodown input.mcrd -o output.txt
        ```

        とコマンドプロンプトやターミナルで処理すると

        \mcrd-output`output.txt` ```
          Hello World!
        ```
        
        が得られます。「何もしていないじゃないか！」と思われても仕方ないので，
        もう少しMacrodownを勤勉に見せる例を挙げます。
        勿論詳しい仕組みは後述するので，おまじない程度に認識してもかまいません。
        
        \mcrd-input`header.mcrdh` ```
          let \hello s = {Hello, @s;!}
        ```
        \mcrd-input`input.mcrd` ```
          \hello{World} \hello{Macrodown}
        ```
        
        という2つのファイルを用意します。拡張子が違っていることに注意してください。これらを
        
        \mcrd-display```
          macrodown header.mcrdh input.mcrd -o output.txt
        ```
        
        と処理すると
        
        \mcrd-output`output.txt` ```
          Hello, World! Hello, Macrodown!
        ```
        
        なるファイルが出力されます。\file-name`header.mcrdh`で\mcrd`\hello`というマクロが定義され，
        \file-name`input.mcrd`でそれを使用しているというわけです。
        拡張子が\extension`.mcrdh`のものはプログラム階層で函数・マクロを定義している\newword{ヘッダファイル}，
        拡張子が\extension`.mcrd`のものはテキスト階層で文書を記述している\newword{文書ファイル}です。
        このほか入力ファイルの拡張子として\extension{.mcrds}があり，
        これはプログラム階層で記述されながらも文書として出力される\newword{単独ファイル}です。
        例えばさきほど2ファイル要した例も
        
        \mcrd-input`input.mcrds` ```
          let \hello s = {Hello, @s;!} in
            {\hello{World} \hello{Macrodown}}
        ```
        
        とすると1ファイルで等価に記述することができます。
        \mcrd`{\hello{World} \hello{Macrodown}}` の
        最も外側の \mcrd`{` と \mcrd`}` はテキスト階層の開始と終了を表しています。
        プログラム階層中に \mcrd`{` があると，
        その \mcrd`{` の直後からそれに釣り合う \mcrd`}` の直前までがテキスト階層となります。
      }
      \p{
        処理のしやすさを考慮して，言語仕様の解説でもこの単独ファイルを中心に扱います。
        とはいえ大きな文書の記述に単独ファイルを実用することはおそらくほとんどなく，
        デバッグ等に使うと便利という程度です。
      }
      \p{
        非常に小さい例でしたが，Macrodownはこのような仕組みを駆使して
        「共通の処理を抽出し，文字を並べるだけではなく意味を示しながら文書を記述する」
        ことを目的とした，メタなマークアップ言語を設計して使用できるシステムなのです。
      }
    }
    \subsection{変数・函数・マクロの定義}{
      \p{
        \newword{函数}と\newword{マクロ}は基本的にほとんど同様に扱えるもので，
        単に\newword{制御綴}で書かれるものをマクロ，
        制御綴でない普通の変数名のように書かれるものを函数と便宜的に呼び分けているだけです。
        プログラミング言語の機能として用いられる「マクロ」という用語とは大きく異なる概念であることに注意してください。
      }
      \p{
        まず函数については，以下のような\newword{定義式}

        \code-display{
          \synt`let` \meta`hoge` %
            \meta`nvar1` \metadots; \meta`nvarN`
            \synt`=` \meta`ExprA` \synt`in` \meta`ExprB`
        }

        で引数を\math{N}個伴う函数\code{\meta`hoge`}が定義されます。
        定義が有効な範囲を\newword{スコープ}と言い，
        この函数\code{\meta`hoge`}の定義は\code{\meta`ExprB`}がスコープです。
        函数だけでなくマクロも同様の構文で定めることができ，

        \code-display{
          \synt`let` \synt`\`\meta`piyo` \meta`var1` \metadots; \meta`varN`
            \synt`=` \meta`ExprA` \synt`in` \meta`ExprB`
        }

        で \code{\synt`\`\meta`piyo`} が \code{\meta`ExprB`} をスコープとして定義されます。
        なお，普通積極的には用いませんが，名前のない函数は

        \code-display{
          \synt`(function` \meta`nv1` \metadots; \meta`nvN`
          \synt`->` \meta`Expr` \synt`)`
        }

        で表現することができます。例えば与えられた整数を2乗する函数は
        \mcrd`(function n -> n * n)` です。

        \code-display{
          \synt`\`\meta`hoge`\ \synt`{`\meta`Arg1`\synt`}`\metadots;\synt`{`\meta`ArgN`\synt`}`
        }

        で各 \code{\meta`varI`} に \code{\meta`ArgI`} が格納された上で定義式の \code{\meta`Expr`} が評価されます。
        定義された函数をプログラム階層で使うときは単に引数を並べることで適用します。
        例えば
        
        \mcrd-input`test.mcrds` ```
          let f x = x * x in arabic (f (f 3))
        ```
        
        に対する出力は
        
        \mcrd-output`test.txt` ```
          81
        ```
        
        となります。Macrodownにはユーザが定儀せずとも最初から備わっている函数とマクロ\footnote{
          ユーザが定義しようとしても原理的に定義できないものがほとんどです。
        }がいくつもあり，これを\newword{プリミティヴ}と呼びます。
        上の例で登場した\mcrd`*`は整数の乗算をする二項演算子，\mcrd`arabic`は整数を文字列に変換するプリミティヴです。
        二項演算子は中置的な構文をとる特殊なプリミティヴです。ちなみに，もし入力を

        \mcrd-input`test.mcrds` ```
          let f x = x * x in f (f 3)
        ```
        
        としたならば，これは\mcrd`81`という整数値になるはずが，
        Macrodownは文字列値しか出力することができないので，
        
        \mcrd-display```
          ! [ERROR AT TYPECHECKER] the output of 'test.mcrds' is not string.
        ```
        
        とエラーが返されるようになっています。
        型システムについては直後の節で述べますが，
        Macrodownは\type(String);型の値のみをテキストファイルとして出力できるようになっており，
        したがって整数値\mcrd`81`に\mcrd`arabic`を適用して\mcrd`{81}`という文字列に変換してやる必要があるのです。
      }
    }
    \subsection{型システムの基本}{
      \p{
        Macrodownは\newword{強い静的型つけ}の型システムを採用しています。
        \newword{型}とはプログラムの整合性を実際に評価することなく検証するための有力かつ簡潔な方法のひとつですが，
        ひとまずは“値には特定の型がついている”と考えて差し支えありません。
        \newword{基本型}，すなわちMacrodownに最初から備わっている型は
        \itemize{
          * \type(String);型
          * \type(Int);型
          * \type(Bool);型
          * \type(Unit);型
        }
        で，\type(String);型は文字列値，\type(Int);型は整数値，\type(Bool);型は真理値に対応しています。
        \type(Unit);型は原則として\mcrd`()`という値だけにつけられる\footnote{
          正確には\mcrd`()`だけでなくファイルの終端に附加される\mcrd`finish`という値にも\type(Unit);型がつきますが，
          これはユーザの手で入力するものではないので意識する必要はありません。
        }型で，最初のうちは“voidのようなもの”と捉えていてもかまいません。
      }
      \p{
        Macrodownでは函数・マクロも値であり，
        \newword{型つきラムダ計算}という体系をもとにした型つけ規則により型がつきます。
        \type(Meta`s`);型の値を受け取って\type(Meta`t`);型の値を返す函数・マクロは
        \type(Func(Meta`s`, Meta`t`));型を持ちます。
        例えば前節で登場した\mcrd`arabic`は\type(Int);型の値を受け取って\type(String);型の値を返す函数であり，
        これを表して\type(Func(Int, String));型を持っていると扱われます。
        \type(Func(Meta`s`, Meta`t`));型の函数・マクロが何らかの値に適用されるとき，
        引数が\type(Meta`s`);型を持っていないと型が整合していないとみなし，
        実際に評価が行なわれる前にその不整合を検出してエラーを返します。
        これが\newword{静的型検査}という仕組みです。
        \type(Meta`s`);型の値と\type(Meta`t`);型の値を受け取って\type(Meta`u`);型の値を返す2変数函数については，
        \type(Func(Meta`s`, Paren(Func(Meta`t`, Meta`u`))));のように，
        1つ目の引数を渡すと\type(Func(Meta`t`, Meta`u`));型の値を返し，
        これに2つ目の引数を渡すと\type(Meta`u`);型の値を返す，とみなします。
        \newword{Curry化}と呼ばれる概念です。また，函数も値ですから，函数に函数を適用することもできます。
        例えば
        
        \mcrd-input`test.mcrds` ```
          let is-positive-at-0 f = if 0 < f 0 then {T} else {F}

          let succ n = n + 1
          let polyn x = x * x + 2 * x - 1

          in (is-positive-at-0 succ) ^ (is-positive-at-0 polyn)
        ```

        で定義されている\mcrd`is-bigger-at-0`は\type(Func(Int, Int));型の値を受け取って\type(String);型を返すので，
        \type(Func(Func(Int, Int), String));型を持ちます。上のコードに対する出力は

        \mcrd-output`test.txt` ```
          TF
        ```
        
        となります。この例からもわかるように，
        \type(Func(Meta`s`, Paren(Func(Meta`t`, Meta`u`))));型と
        \type(Func(Func(Meta`s`, Meta`t`), Meta`u`));型とは一致しません。
        以降では前者の\type(Func(Meta`s`, Paren(Func(Meta`t`, Meta`u`))));型を
        \type(Func(Meta`s`, Func(Meta`t`, Meta`u`)));型と略記することにします。
        すなわち，\type(Func(Meta` `, Meta` `));は右結合です。
      }
      \p{
        函数の型をはじめとして，“より小さい型”から“より大きい型”をつくる構造は
        \itemize{
          * \type(Func(Meta`s`, Meta`t`));（\type(Meta`s`);型から\type(Meta`t`);型への函数の型）
          * \type(List(Meta`t`));（\type(Meta`t`);型の\newword{リスト型}）
          * \type(Ref(Meta`t`));（\type(Meta`t`);型への\newword{参照型}）
          * \type(Prod[Meta`s1`; Meta`s2`; Meta{\metadots;}; Meta`sN`]);
              （\type(Meta`s1`);，\type(Meta`s2`);，…，\type(Meta`sN`);型の\newword{直積型}）
        }
        があります。これらの型の構成はいずれも値の扱い方と合わせて後述します。
      }
      \p{
        また，前節では乗算 \mcrd`*` を用いましたが，算術演算子には
        \itemize{
          * 乗算 \mcrd-type(`*`)(Func(Int, Func(Int, Int))); 
          * 除算 \mcrd-type(`/`)(Func(Int, Func(Int, Int)));
          * 剰餘 \mcrd-type(`mod`)(Func(Int, Func(Int, Int)));
          * 加算 \mcrd-type(`+`)(Func(Int, Func(Int, Int)));
          * 減算 \mcrd-type(`-`)(Func(Int, Func(Int, Int)));
        }
        があります。\mcrd`-` は単項演算子としても使用することができます。
        なお，二項演算子は \mcrd`(` と \mcrd`)` で囲うことで普通の函数のように使うことができます。
        例えば \mcrd`(function n -> 3 + n)` と \mcrd`(+) 3` は同等です。
      }
    }
    \subsection{マクロの適用}{
      \p{
        前述の通り，マクロもプログラム階層に於いて函数とまったく同様の構文で定義することができました。
        しかし，函数と異なりマクロはプログラム階層では適用することができず，必ずテキスト階層で用います。
        テキスト階層では，引数は多くの場合\type(String);型であり，
        これは引数となる各文字列を原則として\mcrd`{`と\mcrd`}`で括ることによって与えます。
        例えば

        \mcrd-input`test.mcrds` ```
          let \test x y = {Ma@x;r@y;down} in
              {\test{c}{o}, \test{}{k}}
        ```

        に対する出力は

        \mcrd-output`test.txt` ```
          Macrodown, Markdown
        ```

        となります。
        \type(String);型の変数\code{\meta{piyo}}に格納された中身をテキスト階層中で取り出すには
        \code{\synt`@`\meta{piyo}\synt`;`}とします。
        或いは，文字列結合演算子 \mcrd-type(`^`)(Func(String, Func(String, String)));を用いて

        \mcrd-input`test.mcrds` ```
          let \test x y = {Ma} ^ x ^ {r} ^ y ^ {down} in
            {\test{c}{o}, \test{}{k}}
        ```

        としても同様です。
      }
      \p{
        なお，マクロを制御綴で記述する仕様になっているために，テキスト階層に於いて
        文字 \mcrd`\`，\mcrd`{`，\mcrd`}`，\mcrd`@` は
        文字そのものとして直接書くことができません。
        また，これらに加えて \mcrd`` ` `` も同様に文字そのものとしては書けません。
        これらの文字を文字そのものとして書くには
        \mcrd`\\`，\mcrd`\{`，\mcrd`\}`，\mcrd`\@`，\mcrd``\` `` とエスケープする必要があります。
        実際にはいちいちエスケープしていては面倒なので，
        後述するリテラル階層という機能によりさらに簡潔に記述することができます。
      }
      \p{
        定義式を用いて変数や引数のないマクロも定義できます。
        引数のないマクロは，使用の際にセミコロンをつけます。例えば

        \mcrd-input`no-arg.mcrds` ```
          let \mcrd = {Macrodown} in {Hello, \mcrd;!}
        ```

        に対する出力は

        \mcrd-output`no-arg.txt` ```
          Hello, Macrodown!
        ```

        となります。
      }
      \p{
        引数に文字列以外の値を与えることもできます。
        例として，整数値を2つ渡すとそれらの和を文字列にし，単位をつけて返すマクロ \mcrd`\sumstr` を定義してみましょう。
        
        \mcrd-input`header.mcrdh` ```
          let \sumstr m n u = (arabic (m + n)) ^ u
        ```
        
        これを文書中で使うには
        
        \mcrd-input`doc.mcrd` ```
          \sumstr(3)(4){個}
        ```
        
        というように文字列でない値を \mcrd`(` と \mcrd`)` で括って与えます。これらを処理すると
        
        \mcrd-output`doc.txt` ```
          7個
        ```
        
        とめでたく出力されることとなります。ただし注意として，
        \mcrd`{` と \mcrd`}` で括られた引数（\newword{テキスト引数}）が存在する時，
        \mcrd`(` と \mcrd`)` で括られた引数（\newword{プログラム引数}）はいずれも
        どのテキスト引数よりも手前になければなりません。
        そのうえ，すべての引数がプログラム引数である場合，末尾には必ず \mcrd`;` をつけねばなりません。
        したがって，\mcrd`\sumstr` を

        \mcrd-input`header.mcrdh` ```
          let \sumstr u m n = (arabic (m + n)) ^ u
        ```
        
        という引数の順序で定義して
        
        \mcrd-input`doc.mcrd` ```
          \sumstr{個}(3)(4)
        ```
        
        とすることはできません。
        この入力だと \mcrd`{個}` に \mcrd`{` が後続しないため「引数は1つである」と判断され，
        残りの \mcrd`(3)(4)` はすべて単なる文字列と解釈されてしまいます。したがって
        \mcrd`\sumstr` は\type(Func(String, Func(Int, Func(Int, String))));型で
        適用結果は\type(String);型でなければならないのに
        引数として\type(String);型の値1つしか与えられていないので，
        型検査で不整合と判断しMacrodownはエラーを返します。
        
        \mcrd`(3)(4)` が単なる文字列になっていることは，代わりに

        \mcrd-input`header.mcrdh` ```
          let \sumstr t = {A@t;B}
        ```
        \mcrd-input`doc.mcrd` ```
          \sumstr{個}(3)(4)
        ```

        を処理すると
        
        \mcrd-output`doc.txt` ```
          A個B(3)(4)
        ```
        
        が出力されることからもわかります。
        なお，あまりおすすめしませんが，
        文字列値はテキスト引数ではなくプログラム引数で与えることもできるので，先ほどのように

        \mcrd-input`header.mcrdh` ```
          let \sumstr u m n = (arabic (m + n)) ^ u
        ```

        の引数の順序で定義したとしても
        
        \mcrd-input`doc.mcrd` ```
          \sumstr( {個} )(3)(4);
        ```
        
        と使うことができ，やはり処理するとその出力は

        \mcrd-output`doc.txt` ```
          7個
        ```
        
        となります。型さえ整合していれば，
        構文上でテキスト引数かプログラム引数かは問わない，ということです。
      }
    }
    \subsection{条件分岐}{
      \p{
        条件分岐は単純明快で，
        
        \code-display{
          \synt{if} \meta{ExprB} \synt{then} \meta{ExprT} \synt{else} \meta{ExprF}
        }
        
        の構文を用います。\code{\meta{ExprB}} は
        真偽値を表す\type(Bool);型を持ち，これを評価して \mcrd`true` であった場合は
        \code{\meta{ExprT}}を評価してその結果を，
        \mcrd`false` であった場合は
        \code{\meta{ExprF}}を評価してその結果を返します。
        例として1つの整数値をFizzBuzz上の表現にするマクロ \mcrd-type(`\fb`)(Func(Int, String));
        を定義して使ってみましょう。
        
        \mcrd-input`input.mcrds` ```
          let \fb n =
            if n mod 5 == 0 then
              if n mod 3 == 0 then {FizzBuzz} else {Buzz}
            else
              if n mod 3 == 0 then {Fizz} else arabic n
          
          in {
            \fb(1);, \fb(3);, \fb(6);, \fb(10);, \fb(15);, \fb(21);, \fb(28);
          }
        ```
        \mcrd-output`output.txt` ```
          1, Fizz, Fizz, Buzz, FizzBuzz, Fizz, 28
        ```
      }
      \p{
        整数の比較で真理値を返す演算子として
        \itemize{
          * 等価演算子 \mcrd-type(`==`)(Func(Int, Func(Int, Bool)));
          * 非等価演算子 \mcrd-type(`<>`)(Func(Int, Func(Int, Bool)));
          * 不等号演算子 \mcrd-type(`>=`)(Func(Int, Func(Int, Bool)));
          * 不等号演算子 \mcrd-type(`<=`)(Func(Int, Func(Int, Bool)));
          * 不等号演算子 \mcrd-type(`>`)(Func(Int, Func(Int, Bool)));
          * 不等号演算子 \mcrd-type(`<`)(Func(Int, Func(Int, Bool)));
        }
        があります。またいわゆる論理演算子として
        \itemize{
          * 選言 \mcrd-type(`||`)(Func(Bool, Func(Bool, Bool)));
          * 連言 \mcrd-type(`&&`)(Func(Bool, Func(Bool, Bool)));
          * 否定 \mcrd-type(`not`)(Func(Bool, Bool));
        }
        があります。
      }
    }
    \subsection{文字列操作プリミティヴ}{
      \p{
        文字列を“直接見る”或いは“加工する”プリミティヴとして
        \itemize{
          * \mcrd-type(`\deeper`)(Func(String, String));
          * \mcrd-type(`string-length`)(Func(String, Int));
          * \mcrd-type(`string-sub`)(Func(String, Func(Int, Func(Int, String))));
          * \mcrd-type(`same`)(Func(String, Func(String, Bool)));
        }
        があります。
        \mcrd`\deeper` は出力される文字列に於けるインデントを深めて返し，
        \code{\synt`string-length` \meta{s}} は与えられた文字列 \code{\meta{s}} の長さを返し，
        \code{\synt`string-sub` \meta{s} \meta{i} \meta{l}} は
        文字列 \code{\meta{s}} の \code{\meta{i}} 文字目から \code{\meta{l}} 文字を返し，
        \code{\synt`same` \meta{s} \meta{t}} は
        文字列 \code{\meta{s}} と \code{\meta{t}} が一致していれば真を，そうでなければ偽を返します。
        \mcrd`\deeper`は少し複雑なので，以下に例を掲げておきます。
        
        \mcrd-input`deeper.mcrds` ```
          let \p1 cont = {
            <p>@cont;</p>
          }
          let \p2 cont = {
            <p>
              @cont;
            </p>
          }
          let \p3 cont = {
            <p>\deeper{@cont;}</p>
          }
          let \p4 cont = {
            <p>\deeper{
              @cont;
            }</p>
          }
          let \p5 cont = {
            <p>
              \deeper{@cont;}
            </p>
          }
          in {
            [\p1{
              The quick brown fox jumps over the lazy dog.
            }]
            \p2{
              The quick brown fox jumps over the lazy dog.
            }
            \p3{
              The quick brown fox jumps over the lazy dog.
            }
            \p4{
              The quick brown fox jumps over the lazy dog.
            }
            \p5{
              The quick brown fox jumps over the lazy dog.
            }
          }
        ```
        \mcrd-output`deeper.html` ```
[<p>The quick brown fox jumps over the lazy dog.</p>]
<p>
The quick brown fox jumps over the lazy dog.
</p>
<p>
  The quick brown fox jumps over the lazy dog.
</p>
<p>
  The quick brown fox jumps over the lazy dog.
</p>
<p>
The quick brown fox jumps over the lazy dog.
</p>
        ```
        
        文字\mcrd`[`と\mcrd`]`は改行位置を確認する目的で挿入したものです。
        第一に，Macrodownは\mcrd`{`の後ろか\mcrd`}`の手前にある改行文字と空白文字の連続は無視します。
        したがって\mcrd`\p1`では\mcrd`<p>`の手前や\mcrd`</p>`の直後に改行文字は出力されていません。
        続いて\mcrd`\p2`の結果からわかるように，Macrodownはコード中のインデントを出力に反映しません。
        したがって，出力の\mcrd`<p>`と\mcrd`</p>`の間をインデントするには\mcrd`\p3`，\mcrd`\p4`，\mcrd`\p5`のように
        \mcrd`\deeper`を挿入する必要があります。
      }
      \p{
        \mcrd`\p3`と\mcrd`\p4`からわかるように，\mcrd`\deeper`は前後に\newword{柔らかい改行文字}を挿入して出力します．
	入力の改行文字には柔らかい改行文字と硬い改行文字があり，誤解のない場合はまとめて改行文字と呼びます。
	硬い改行文字は出力時に必ず改行文字になりますが，柔らかい改行文字は出力直前の時点で
	\itemize{
	  * 前後いずれかに硬い改行文字がある場合
	  * 前に柔らかい改行文字がある場合
	}
	は無視されます。
        すなわち，硬い改行文字は何個並んでもその個数だけ改行文字として出力されますが，
	柔らかい改行文字は何個並んでも1個の扱いです。特に\LaTeX;のような空行に意味のある言語をターゲットにする場合は注意してください。
      }
      \p{
        なお，\mcrd`\deeper`は函数・マクロ定義でのみ使用することを意図された機能です。
        文書本体に直接\mcrd`\deeper`を記述することは，
        煩雑化と意味マークアップの阻碍に繋がるので望ましくないでしょう。
      }
      \p{
        その他は
        
        \mcrd-input`string.mcrds` ```
          let \is-mcrd s = if same s {Macrodown} then {Yes} else {No}
          let \len s  = arabic (string-length s)
          let \sub i l s = string-sub s i l
          in {
            \is-mcrd{Markdown}/\len{Markdown}/\sub(3)(4){Markdown}
            \is-mcrd{Macrodown}/\len{Macrodown}/\sub(2)(4){Macrodown}
          }
        ```
        \mcrd-output`string.txt` ```
          No/8/kdow
          Yes/9/crod
        ```
        
        のように単純です。
      }
      \p{
        ただし，これらのプリミティヴの機能は，厳密には上記の説明ほど明快ではありません。
        ほとんどの場合は上のような理解で意図通り使用することができますが，用いられ方によっては
        \type(String);型の仕様とMacrodownの評価規則を正確に知らないと不可解に近いような挙動を見せてしまいます。
        これについては後の\newword{最終値参照}と\newword{グローバルハッシュ}の節で述べます。
      }
    }
    \subsection{再帰}{
      \p{
        条件分岐を使えば，再帰函数によって繰り返し処理を書くこともできます。
        全然実用的ではありませんが，
        1から与えられた整数までを並べた文字列を返す函数 \mcrd`\lineup` を定義して使ってみましょう。
        
        \mcrd-input`lineup.mcrds` ```
          let \lineup n =
            if n <= 0 then {} else
              let s = arabic n in {\lineup(n - 1);[@s;]}

          in {\lineup(20);}
        ```
        \mcrd-output`lineup.txt` ```
          [1][2][3][4][5][6][7][8][9][10][11][12][13][14][15][16][17][18][19][20]
        ```
        
        いわゆる函数型プログラミングの経験がない方には少し想像しづらいかもしれませんが，
        慣れてしまえばループ処理よりもずっと少ない手間で書くことができます。
      }
    }
    \subsection{リストとパターンマッチ}{
      \p{
        \newword{リスト}は，同じ型のデータを順序を区別して並べた値です。伸長したり削減したりすることができます。
        値\mcrd`[]`を\newword{空リスト}と呼び，\type(List(Bound`a`));型を持ちます。
        どんな型のリストでも空の場合は\mcrd`[]`を用います。
        また，値\code{\meta`v`}の後ろにリスト\code{\meta`l`}を繋げたリストを
        \code{\meta`v` \synt`::` \meta`l`}と書きます。
        例えば\mcrd`3 :: []`は長さ1のリスト，\mcrd`3 :: (1 :: [])`は長さ2のリストであり，
        それぞれ\type(List(Int));型を持ちます。
        \mcrd`::`は\newword{コンス}と呼ばれ，
        \type(Func(Func(Bound`a`, List(Bound`a`)), List(Bound`a`)));型をもつ右結合の二項演算子です。
        右結合性より\mcrd`3 :: (1 :: [])`は\mcrd`3 :: 1 :: []`と括弧を略すことができます。
        同様にどんどん伸ばすことができ，
        
        \mcrd-display```
          3 :: 1 :: 4 :: 1 :: 5 :: 9 :: 2 :: []
        ```
        
        などとします。このような成分を書いた具体的なリストは，糖衣構文として
        
        \mcrd-display```
          [3; 1; 4; 1; 5; 9; 2]
        ```

        のように\code{\synt`[`}と\code{\synt`]`}で括って各要素を\code{\synt`;`}で区切って書くこともできます。
      }
      \p{
        \mcrd`::`の持つ型により，リストでは全ての要素の型が一致していなければなりません。
        \type(Meta`t`);型の要素を持つリストの型は\type(List(Meta`t`));であり，
        例えば\type(Int);型のリストは\type(List(Int));型になります。
        なお，実際に文書中のテキスト階層で用いるリストの多くは
        \type(List(String));型のリストをマクロの引数とする場合ですが，これは

        \mcrd-display```
          \somecs( [{hoge}; {piyo}; {fuga}; {moge}] );
        ```

        と複雑に入り組んだ書き方をせずとも

        \mcrd-display```
          \somecs{|hoge|piyo|fuga|moge|}
        ```

        と省略して書くことができます。
        プログラム階層でも \mcrd`{|hoge|piyo|fuga|moge|}` で
        \mcrd`[{hoge}; {piyo}; {fuga}; {moge}]` の省略として使えます。
      }
      \p{
        リストの各要素を取り出す操作には，\newword{パターンマッチ}を用います。一般にパターンマッチは

        \code-display{
          \synt`match` \meta{Expr0} \synt`with`\code-break;
          \synt`|` \meta{pat1} \synt`->` \meta{Expr1}\code-break;
          \synt`|` \meta{pat2} \synt`->` \meta{Expr2}\code-break;
          \metadots;\code-break;
          \synt`|` \meta{patN} \synt`->` \meta{ExprN}
        }
        
        という記法をとり，\code{\meta{Expr0}} の値が
        パターン \code{\meta{pat1}} に合致する場合は \code{\meta{Expr1}} を返し，
        パターン \code{\meta{pat1}} に合致しない場合は
        次の \code{\meta{pat2}} と照らしあわせて合致すれば \code{\meta{Expr2}} を返し，
        ……という，上から順にマッチする表現を探して対応する値を返す仕組みです。
        具体的に次の例を見てみましょう。
        
        \mcrd-input`enclose.mcrds` ```
          let \enclose lst =
            match lst with
            | []       -> {}
            | hd :: tl -> {(@hd;)\enclose(tl);}
          
          in {\enclose{|hoge|piyo|fuga|moge|}}
        ```
        
        という入力に対して
        
        \mcrd-output`enclose.txt` ```
          (hoge)(piyo)(fuga)(moge)
        ```
        
        という文字列になります。
      }
      \p{
        リストを再帰的に扱う例を見てみましょう。
        \type(List(String));型の値を受け取り，
        各要素をHTMLのリストの項目として並べたものを返す
        マクロ \mcrd-type(`\ul`)(Func(List(String), String));を定義します。

        \mcrd-input`ul.mcrdh` ```
          let sub-ul lst =
            match lst with
            | []       -> {}
            | hd :: tl -> {<li class="list-content">@hd;</li>} ^ break ^ (sub-ul tl)

          let \ul lst = {<ul>\deeper(sub-ul lst);</ul>}
        ```
        \mcrd-input`ul.mcrd` ```
          \ul{|hoge|piyo|fuga|moge|}
        ```

        を処理した出力は
        
        \mcrd-output`ul.txt` ```
          <ul>
            <li class="list-content">hoge</li>
            <li class="list-content">piyo</li>
            <li class="list-content">fuga</li>
            <li class="list-content">moge</li>
          </ul>
        ```

        となります。ここで挙げた例は4要素のリストですが，
        実際の文書を記述するにあたってはもっと長いリストも登場することでしょう。
        そのように何度も同じ記述が繰り返される場合，すべて手で打つのではなく，
        共通部分は再帰的なマクロ定義に含ませて，異なる部分をリストの各要素として与えることにより，
        効率的にマークアップすることができます。
      }
      \p{
        ついでに再帰の例として有名な左畳み込み演算
        \mcrd-type(`foldl`)(Func(Func(Bound`a`, Func(Bound`b`, Bound`a`)), Func(Bound`a`, Func(List(Bound`b`), Bound`a`))));
        とそれを使った函数を掲げておきます。

        \mcrd-input`foldl.mcrds` ```
          let foldl f i lst =
            match lst with
            | []       -> i
            | hd :: tl -> foldl f (f i hd) tl

          let sum = foldl (+) 0
          let \sum lst = arabic (sum lst)

          let count m a = m + 1
          let length = foldl count 0
          let \length lst = arabic (length lst)

          let enclose s t = {@s;[@t;]}
          let \display = foldl enclose {}

          in {
            \sum    ( [3; 1; 4; 1; 5; 9; 2] );
            \length ( [3; 1; 4; 1; 5; 9; 2] );
            \display{|hoge|piyo|fuga|moge|}
          }
        ```
        \mcrd-output`foldl.txt` ```
          25
          7
          [hoge][piyo][fuga][moge]
        ```
        リストになっている整数の総和を返す函数 \mcrd-type(`sum`)(Func(List(Int), Int));，
        リストの長さを返す函数 \mcrd-type(`length`)(Func(List(Bound`a`), Int));，
        リストの文字列各々を四角括弧で括って並べるマクロ \mcrd-type(`\display`)(Func(List(String), String));
        がそれぞれ \mcrd`foldl` を使って非常に簡潔に定義できています。
      }
    }
    \subsection{相互再帰}{
      \p{
        再帰は“自己再帰”に限らず，複数の函数が“相互に依存しあう”こともできます。
        例えば奇数番目が\mcrd`style-odd`クラス，偶数番目が\mcrd`style-even`クラスに指定される
        HTMLのリストを書きたいときは

        \mcrd-input`mut.mcrds` ```
          let ul-odd lst =
            match lst with
            | []       -> {}
            | hd :: tl -> {<li class="style-odd">@hd;</li>} ^ (ul-even tl)

          and ul-even lst =
            match lst with
            | []       -> {}
            | hd :: tl -> {<li class="style-even">@hd;</li>>} ^ (ul-odd tl)

          let \ul lst = {<ul>\deeper(ul-odd lst);</ul>}
          in {
            \ul{|hoge|piyo|fuga|moge|}
          }
        ```
        
        と \mcrd`and` を用いて“並列的に” \mcrd`ul-odd` と \mcrd`ul-even` を宣言して書くと
        
        \mcrd-output`mut.txt` ```
          <ul>
            <li class="style-odd">hoge</li>
            <li class="style-even">piyo</li>
            <li class="style-odd">fuga</li>
            <li class="style-even">moge</li>
          </ul>
        ```
        
        が出力されます。もしかしたら
        「なぜわざわざ \mcrd`and` で書く必要があるんだ？ \mcrd`let` に置き換えてもいいんじゃないか」
        と思われるかもしれませんが，これはスコープの問題で，もしも

        \code-display{
          \synt{let} \meta{f} \meta{x1} \metadots; \meta{xM} \synt{=} \meta{ExprA}\code-break;
          \code-break;
          \synt{let} \meta{g} \meta{y1} \metadots; \meta{yN} \synt{=} \meta{ExprB}
        }
        
        と書くと，
        \code{\meta{ExprB}} で \code{\meta{f}} を使うことができても
        \code{\meta{ExprA}} で \code{\meta{g}} を使うことができないのです。

        \code-display{
          \synt{let} \meta{f} \meta{x1} \metadots; \meta{xM} \synt{=} \meta{ExprA}\code-break;
          \code-break;
          \synt{and} \meta{g} \meta{y1} \metadots; \meta{yN} \synt{=} \meta{ExprB}
        }
        
        とすると，これは
        \code{\meta{ExprB}} で \code{\meta{f}} を使うことも
        \code{\meta{ExprA}} で \code{\meta{g}} を使うこともできるようにスコープが設定されています。
        このように \mcrd`and` を駆使せねばならないことは一見面倒なように見えますが，
        定義の依存関係を明確に意識して書ける，
        すなわち一度書いた定義を後で書き換えるとどの範囲に影響が及ぶかということが明確になるという意味で有用です。
      }
    }
    \subsection{ファイル分割}{
      \p{
        これまでは単独ファイルの例を多用してきましたが，実用上は函数とマクロの定義をヘッダファイルに，
        “文書本体”を文書ファイルに記述する方が便利です。
        というのも，複数のターゲット言語，例えば\LaTeX;とHTML/CSSの両方に出力したいとき，
        “文書本体”を共通のデータにしてヘッダファイルのみを入れ替えることでどちらも出力することができる，
        という利点があるためです。
        その他，単独ファイルだと先頭の函数とマクロの定義がかさばって見づらい，という問題も解消できます。
      }
      \p{
        ヘッダファイルはプログラム階層で記述し，

        \code-display{
          \synt{let} \meta{f1} \meta{x11} \metadots; \meta{x1N} \synt{=} \meta{Expr1}\code-break;
          \code-break;
          \synt{let} \meta{f2} \meta{x21} \metadots; \meta{x2N} \synt{=} \meta{Expr2}\code-break;
          \code-break;
          \metadots;\code-break;
          \code-break;
          \synt{let} \meta{fM} \meta{xM1} \metadots; \meta{xMN} \synt{=} \meta{ExprM}
        }
        
        というように \mcrd`let` で宣言を並べます。
        この宣言が並ぶ“最も外側の領域”を\newword{大域環境}と呼びます。
        大域環境の \mcrd`let` は
        \code{\synt{let} \meta{hoge} \synt{=} \meta{Expr} \synt{in} \meta{Expr}}
        のように \mcrd`in` をつける必要はありませんが，上のコードは実際には

        \code-display{
          \synt{let} \meta{f1} \meta{x11} \metadots; \meta{x1N} \synt{=} \meta{Expr1} \synt{in}\code-break;
          \code-tab;
          \synt{let} \meta{f2} \meta{x21} \metadots; \meta{x2N} \synt{=} \meta{Expr2} \synt{in}\code-break;
          \code-tab;\code-tab;
          \metadots;\code-break;
          \code-tab;\code-tab;\code-tab;
          \synt{let} \meta{fM} \meta{xM1} \metadots; \meta{xMN} \synt{=} \meta{ExprM} \synt{in}\code-break;
          \code-tab;\code-tab;\code-tab;\code-tab;
          \synt{finish}
        }
        
        と同等となります。最後の \mcrd`finish` は実際には書けないトークンで，値としては \mcrd`()` ですが，
        これが書かれた場所から“見える”函数・マクロの定義を次以降のファイルの読み込みに引き継ぐという機能を持っています。
      }
%      \p{
%        大域環境での相互再帰はやはり
%
%        \code-display{
%          \synt{let} \meta{f1} \meta{x11} \metadots; \meta{x1N} \synt{=} \meta{Expr1}\code-break;
%          \code-break;
%          \synt{and} \meta{f2} \meta{x21} \metadots; \meta{x2N} \synt{=} \meta{Expr2}\code-break;
%          \code-break;
%          \metadots;\code-break;
%          \code-break;
%          \synt{and} \meta{fM} \meta{xM1} \metadots; \meta{xMN} \synt{=} \meta{ExprM}
%        }
%
%        と書きますが，
%        「定義の依存関係が明白になるなんて全然有用に思えん！\quad;\mcrd`and` なんて意識しないで書きたい！」
%        という方のために \mcrd`mutual`～\mcrd`end-mutual` という糖衣構文を用意しており，
%        
%        \code-display{
%          \synt{mutual}\code-break;
%          \code-tab;\synt{let} \meta{f1} \meta{x11} \metadots; \meta{x1N} \synt{=} \meta{Expr1}\code-break;
%          \code-break;
%          \code-tab;\synt{let} \meta{f2} \meta{x21} \metadots; \meta{x2N} \synt{=} \meta{Expr2}\code-break;
%          \code-break;
%          \code-tab;\metadots;\code-break;
%          \code-break;
%          \code-tab;\synt{let} \meta{fM} \meta{xM1} \metadots; \meta{xMN} \synt{=} \meta{ExprM}\code-break;
%          \synt{end-mutual}
%        }
%        
%        と書くことで，上に掲げた \mcrd`and` を用いたものと同等となります。
%      }
    }
    \subsection{直積とパターンマッチ}{
      \p{
        \newword{直積}または\newword{タプル}は，座標のように複数の値をまとめてひとつの値として扱う方法です。
        リストのように伸長や削減をすることはできませんが，それぞれ異なる型の値から構成することができます。
        単純に括弧でくくってコンマで区切り，\mcrd`({Grothendieck}, 51)`のように書きます。この値は
        \type(Prod[String; Int]);型です。
        このほか\mcrd`(true, arabic)`は\type(Prod[Bool; Func(Int, String)]);型であるなど，自由に組み合わせることができます。
      }
      \p{
        ただ組み合わせられるだけでは意義がなく，直積の値を“分解”して使う必要があります。
        分解はやはりパターンマッチによります。3次元座標を例にとって見てみます。
        3次元ベクトルの大きさの2乗を返す函数\mcrd-type(`square-size`)(Func(Prod[Int; Int; Int], Int));は
        
        \mcrd-input`3d.mcrdh` ```
          let square-size p =
            match p with
            | (x, y, z) -> x * x + y * y + z * z
        ```
        
        のように定義できます。同様に，和を返す函数
        \mcrd-type(`add`)(Func(Prod[Int; Int; Int], Prod[Int; Int; Int]));は
        
        \mcrd-input`3d.mcrdh` ```
          let add p1 p2 =
            match (p1, p2) with
            | ((x1, y1, z1), (x2, y2, z2)) -> (x1 + x2, y1 + y2, z1 + z2)
        ```
        
        と定義できます。一般に
        \code{\synt`(`\meta`a`\synt`,` \meta`b`\synt`,` \meta`c`\synt`)`}と
        \code{\synt`(`\meta`a`\synt`,` \synt`(`\meta`b`\synt`,` \meta`c`\synt`)`\synt`)`}と
        \code{\synt`(`\synt`(`\meta`a`\synt`,` \meta`b`\synt`)`\synt`,` \meta`c`\synt`)`}とが互いに区別され，
        それぞれ
        \type(Prod[Meta`s`; Meta`t`; Meta`u`]);型，
        \type(Prod[Meta`s`; Prod[Meta`t`; Meta`u`]]);型，
        \type(Prod[Prod[Meta`s`; Meta`t`]; Meta`u`]);型をもつことに注意してください。
      }
    }
    \subsection{直和型}{
      \p{
        \newword{直和型}或いは\newword{ヴァリアント型}とは，ユーザが構造を定義する型です。
        リスト，直積では表現するのが冗長になるような構造も，簡潔に表現できることがよくあります。
        例としてトランプカードを扱う型を考えてみましょう。
        スートとランクを直積で表現するという方針であれば，\type(Int);型を用いて
        \mcrd`0`をスペード，\mcrd`1`をハート，\mcrd`2`をダイヤ，\mcrd`3`をクラブとみなし，
        ランクはそのまま\mcrd`1`から\mcrd`13`を使うことにしましょう。
        これに基づけばスペードの3は\mcrd`(0, 3)`，ダイヤのQは\mcrd`(2, 12)`という具合になります。
        ではこれにジョーカー1枚を加える場合はどのように表現すればよいでしょうか。
        シンプルな例としては\mcrd`(4, 0)`に割り当てるという解決法があったりします。
        しかし，このような数値的扱いの方針はすぐに簡潔さを失ってしまい，保守しにくいコードを生む温床になります。
        例えばジョーカーの場合分けを忘れてスートの判定でよくわからないエラーを出してしまうかもしれません。
        この例の程度の大きさであれば修正できるかもしれませんが，
        油断すればコードに意図が現れずマジックナンバーで溢れたりすることが十分ありますし，
        また初めから見落としなくバグを埋め込まずに書くのは結構難しいものです。
      }
      \p{
        そこで直和型が登場します。直和型は
        
        \code-display{
          \synt`type` \type(Meta`t`); \synt`=` \meta`Constr1` \synt`of` \type(Meta`t1`); \synt`|`
            \metadots; \synt`|` \meta`ConstrN` \synt`of` \type(Meta`tN`);
        }
        
        という具合にして\code{\meta`t`}と名づけた型を宣言します。
        \code{\meta`Constr1`}，…，\code{\meta`ConstrN`}は\newword{コンストラクタ}と呼ばれ，
        “型をなす構成子”です。各\code{\synt`of` \type(Meta`tI`);}はコンストラクタがとる引数の型の指定で，
        \code{\synt`of` \type(Unit);}の場合は省略できます。
      }
      \p{
        トランプカードの型を直和型を用いて定義してみましょう。
        
        \mcrd-input`cards.mcrdh` ```
          type suit = Spade | Heart | Diamond | Club
          type card = Normal of suit * int | Joker
        ```
        
        これで定義は終了です。\type(Data`suit`);型はスートを表現し，\type(Data`card`);型はカードを表現しています。
        この定義に基づくと，2つのカードが同じスートかどうかを判定する函数
        \mcrd-type(`same-suit`)(Func(Data`card`, Func(Data`card`, Bool)));と同じランクかどうかを判定する函数
        \mcrd-type(`same-rank`)(Func(Data`card`, Func(Data`card`, Bool)));は
        
        \mcrd-input`cards.mcrdh` ```
          let same-suit c1 c2 =
            match (c1, c2) with
            | (Normal(Spade, _), Normal(Spade, _))     -> true
            | (Normal(Heart, _), Normal(Heart, _))     -> true
            | (Normal(Diamond, _), Normal(Diamond, _)) -> true
            | (Normal(Club, _), Normal(Club, _))       -> true
            | _                                        -> false
          
          let same-rank c1 c2 =
            match (c1, c2) with
            | (Normal(_, r1), Normal(_, r2) -> r1 == r2
            | _                             -> false
        ```
        
        という具合に非常に明瞭に実装することができます。
      }
      \p{
        木構造を扱うときは，再帰性によりさらに効力を発揮します。
        以下は各頂点に整数が記録された二分木のための型\type(Data`tree`);と，
        その頂点の合計を計算する函数\mcrd-type(`vertex-sum`)(Func(Data`tree`, Int));です。
        
        \mcrd-input`tree.mcrds` ```
          type tree = Leaf of int | Node of int * tree * tree
          
          let vertex-sum tr =
            match tr with
            | Leaf(i)         -> i
            | Node(i, lc, rc) -> i + (vertex-sum lc) + (vertex-sum rc)
        ```
      }
      \p{
        ところで，\type(Int);型の木だけでなく\type(String);型の木も使いたいとき，どうすればよいでしょうか。
        素直な方法としては両方とも別個に実装する，すなわち
        
        \mcrd-input`tree.mcrds` ```
          type treeI = LeafI of int | NodeI of int * treeI * treeI
          type treeS = LeafS of string | NodeS of string * treeS * treeS
        ```
        
        のように\type(Data`treeI`);型と\type(Data`treeS`);型をそれぞれ別に書いてしまうということが考えられます。
        しかし，全く同様の構造であるのに型が違えばいちいち明示的に定義を書かねばならないというのはどう考えても煩わしく，
        1度だけ構造を書いて各型で使い回したいものです。そのための仕組みとして\newword{型引数}があります。
        
        \code-display{
          \synt`type` \synt`'`\meta`a1` \metadots; \synt`'`\meta`aM` \type(Meta`t`); \synt`=`
            \meta`Constr1` \synt`of` \type(Meta`t1`); \synt`|`
              \metadots; \synt`|` \meta`ConstrN` \synt`of` \type(Meta`tN`);
        }
        
        という具合に\math{M}個の型引数\code{\synt`'`\meta`a1`}, \metadots;, \code{\synt`'`\meta`aM`}を用いて型を宣言します。
        上の問題意識に対する解答を具体例として掲げると
        
        \mcrd-input`tree.mcrds` ```
          type 'a tree = Leaf of 'a | Node 'a * 'a tree * 'a tree
        ```
        
        となります。この\type(App(Meta`'a`, Data`tree`));型を宣言すると，例えば与えられた木の根にある値を返す函数は
        
        \mcrd-input`tree.mcrds` ```
          let top tr =
            match tr with
            | Leaf(x)       -> x
            | Node(x, _, _) -> x
        ```
        
        と\mcrd-type(`top`)(Func(App(Meta`'a`, Data`tree`), Meta`'a`));で実装することができます。
        この\mcrd`top`は具体的に\type(Meta`'a`);にどの型が入る場合も使い回すことができ，
        \synt`top (Leaf 2)`は\synt`2`に，\synt``top (Node({f}, Leaf{g}, Leaf{n}))``は\synt`{f}`に，それぞれ評価されます。
      }
      \p{
        Macrodownには，ユーザが定義せずとも最初から備わっている直和型が2つあり，ひとつは \type(Data`itemize`);型，もうひとつは
        以下のように定義できる\type(App(Meta`'a`, Data`maybe`));型です。
        
        \mcrd-input`maybe.mcrdh` ```
          type 'a maybe = Just of 'a | Nothing
        ```

        この型は，例えば“失敗するかもしれない演算”に使うことができます。整数の除算はいわゆる割る数が\mcrd`0`であったときにエラーとなりますが，

        \mcrd-input`maybe.mcrdh` ```
          let divide x y =
            match (x, y) with
            | (_, Just 0)      -> Nothing
            | (Just m, Just n) -> Just (m / n)
            | _                -> Nothing
        ```
        
        \mcrd`0`で除算してしまった場合も\mcrd`None`が返ってきます。
        この\type(App(Meta`'a`, Data`maybe`));型について
        「なぜユーザの手によっても簡単に定義できるのに最初から備わっているのか」と思われるかもしれませんが，
        これは後述のクラス名・ID名オプションという機能で使用されるためです。
      }
      \p{
        相互再帰的に依存する直和型の定義は，例えば
        
        \mcrd-input`mut-variant.mcrds` ```
          type odd-tree  = OddLeaf of int
                         | OddNode of int * even-tree * even-tree
          
           and even-tree = EvenLeaf of int
                         | EvenNode of int * odd-tree * odd-tree
        ```
        
        のように\mcrd`and`を用いて定義します。
      }
    }
    \subsection{型シノニム}{
      \p{
        型には別名をつけることができます。
        例えば\type(Prod[Int; Int; Int]);型に\type(Data`vector`);型という別名をあてたい場合は
        
        \mcrd-input`synonym.mcrds` ```
          type vector = int * int * int
        ```
        
        などとします。
      }
    }
    \subsection{リテラル階層}{
      \p{
        テキスト階層では，\mcrd`\`，\mcrd`{`，\mcrd`}`，\mcrd`` ` ``，\mcrd`@` という
        “そのままでは書けない”文字がありました。これらはそれぞれ
        \mcrd`\\`，\mcrd`\{`，\mcrd`\}`，\mcrd``\` ``，\mcrd`\@` とエスケープしなければならないのですが，
        長い定文字列中にこれらの文字が高頻度で出現する場合は非常に面倒です
        （特に\LaTeX;をターゲット言語とするマクロを記述する場合，
        これらの文字をいちいちエスケープしていては大変です）。
        そこでより簡潔に定文字列を書く方法として，プログラム階層で
        
        \mcrd-input`literal1.mcrds` ```
          let s = `In literal areas, you can use letters \, {, }, and @ directly.`
          in s
        ```
        
        と \mcrd`` ` `` で括って書くことで
        
        \mcrd-output`literal1.txt` ```
          In literal areas, you can use letters \, {, }, and @ directly.
        ```

        と出力できるようになっています。これを\newword{リテラル階層}と呼びます。
        「えっ，では \mcrd`` ` `` そのものはどうやって書くんだ」と思われた方，安心してください。
        \mcrd`` ` `` が含まれる文字列は全体を \mcrd``` `` ``` で囲んで
        
        \mcrd-input`literal2.mcrds` ```
          let s = ``You can also use ` in literal areas like this.``
          in s
        ```
        
        \mcrd-output`literal2.txt` ```
          You can also use ` in literal areas like this.
        ```
        
        のように使えます。さらに \mcrd``` `` ```が含まれる文字列は全体を \mcrd```` ``` ```` で囲んで，
        …と文字列中に \mcrd`` ` `` が連続する最大個数よりも多い数の \mcrd`` ` `` で括ってリテラル階層にすることができます。
        左右の個数は同数でなければなりません。
      }
      \p{
        \mcrd`` ` `` \metadots; \mcrd`` ` `` はプログラム階層での文字列だけでなく，テキスト引数として使うこともできます。
        すなわち，例えば
        
        \mcrd-input`literal3.mcrds` ```
          let \test arg = {The argument is @arg;.} in
            {\test`{@bd_gfngfn}`}
        ```
        
        に対しては
        
        \mcrd-output`literal3.txt` ```
          The arg is {@bd_gfngfn}.
        ```
        
        と出力されます。
        リテラル階層を用いて2個以上の連続するテキスト引数を書く場合は，
        それらの引数の間にスペースを空けねばなりません。すなわち
        
        \mcrd-input`literal4.mcrds` ```
          let \test p1 p2 = {First: @p1;, Second: @p2;.} in
            {\test``vis-a`-vis`` `P \/ Q`}
        ```
        \mcrd-output`leteral4.txt` ```
          First: vis-a`-vis, Second: P \/ Q.
        ```
        
        のようにします。これは，スペースを空けないと \mcrd``` `` ``` で始まった
        1個目の引数が \mcrd```` ``` ```` で終了しているとみなされてしまい，
        釣り合いがとれていないという旨のエラーが返されるからです。
      }
    }
    \subsection{クラス名・ID名オプション}{
      \p{
        マクロは適用に於いて\newword{クラス名オプション}および\newword{ID名オプション}をとることができます。
        ここで言うクラス名とID名とは，おおよそHTMLのクラス属性とID属性にそれぞれ対応するものです。
        クラス名オプション，ID名オプションはいずれもアクティヴ階層で使い，
        
        \code-display{
          \synt`\`\meta`cs` \synt`.`\meta`class` \synt`#`\meta`id` \synt`(` \metadots;
        }
        
        のように，マクロを表す制御綴よりも後ろで，どのプログラム引数よりも手前に書きます。
        クラス名オプションとID名オプションはいずれか片方でも構わず，
        また両方書く場合はクラス名オプションを先に書かねばなりません。
        クラス名オプションは先頭の \mcrd`.` を除いた部分が文字列として変数 \mcrd`class` に，
        同様にID名オプションは先頭の \mcrd`#` を除いた部分が文字列として変数 \mcrd`id` に格納されてマクロが適用されます。
      }
      \p{
        マクロ定義中でクラス名オプションの文字列を使用するには，
        まず指定された場合と指定されなかった場合で分岐しなければなりません。
        この分岐のために，直和型の項目で紹介した\type(App(Meta`'a`, Data`maybe`));を用います。
      }
      \p{
        クラス名とID名は，それぞれ\type(App(String, Data`maybe`));型をもつ\mcrd`class-name`と\mcrd`id-name`という変数により，
        制御綴の定義式内で参照することができます。すなわち
        
        \code-display{
          \synt`let` \synt`\`\meta`hoge` \metadots; \synt`=` \meta`ExprA` \synt`in` \meta`ExprB`
        }
        
        の\code{\meta`ExprA`}内で使えます。同時に，このような制御綴の定義式以外では使えません。
        マクロの適用箇所でクラス名\code{\synt`.`\meta`foo`}が指定された場合は\code{\synt`Just {`\meta`foo`\synt`}`}が，
        指定されなかった場合は\code{\synt`Nothing`}が\mcrd`class-name`に格納された状態で評価が行なわれます。
      }
      \p{
        \LaTeX;の例を見てみましょう。
        
        \mcrd-input`header.mcrdh` ```
          let deeper inner = {\deeper{@inner;}}

          let \p inner = `\indent` ^(deeper inner)^ `\par`

          let \sect sect cont =
            `\section{` ^sect^ `}` ^
              ( match id-name with
                | Nothing -> {}
                | Just(s) -> `\label{`^id^ `}` ) ^
              (deeper cont) ^
            `% ---- ----`
        ```
        \mcrd-input`main.mcrd` ```
          \sect{First Title}{
            \p{ The quick brown fox jumps over the lazy dog. }
          }
          \sect #second {Second Title}{
            \p{ My quiz above the kiwi juice needs priceless fixing. }
          }
        ```
        
        上の入力から以下を得ることができます。
        
        \mcrd-output`output.txt` ```
          \section{First Title}
            \indent
              The quick brown fox jumps over the lazy dog.
            \par
          % ---- ----
          \section{Second Title}\label{second}
            \indent
              My quiz above the kiwi juice needs priceless fixing.
            \par
          % ---- ----
        ```
      }
    }
    \subsection{手続き型プログラミング機能}{
      \p{
        これまで函数型プログラミングを基礎に各種機能を紹介してきましたが，
        手続き型プログラミングにあたる機能も存在しています。
        手続き型に洗脳されている皆様におかれましては「なぜそれをもっと早く言わなかったんだ」
        と思われたかもしれませんが，
        手続き的プログラミングは破壊的代入の存在によりいわゆる参照透過性が失われるなど
        相対的に保守を困難にする要素をはらんでいるため，その使用は最小限に留めたいという志向があります。
        といっても，破壊的代入が可能な変数を用いた方がずっと見通しよく処理が書けることも多々あるので，
        これを意図して手続き型の機能を備えつけています。
      }
      \p{
        まず，書き換え可能な変数の宣言は
        
        \code-display{
          \synt`let-mutable` \meta`var` \synt`<-` \meta`ExprA` \synt`in` \meta`ExprB`
        }
        
        で行ないます。こうすると変数 \code{\meta`var`} に \code{\meta`ExprA`} の評価結果が初期値として代入され，
        \code{\meta`ExprB`} をスコープとして使用することができます。
        大域環境では \code{\synt`in` \meta`ExprB`} を書かずに

        \code-display{
          \synt`let-mutable` \meta`var` \synt`<-` \meta`ExprA`
        }
        
        とすることで以降すべての箇所で \code{\meta`var`} を書き換えたり参照したりして使えます。
        このようにして宣言された \code{\meta`var`} は，
        \code{\meta`ExprA`} を\type(Meta`t`);型とすると \type(Ref(Meta`t`));型を持ちます。
        参照は通常の変数とは違い \mcrd`!` をつけて \code{\synt`!` \meta`var`} とします。
        また書き換えは \mcrd`<-` を用いて \code{\meta`var` \synt`<-` \meta`Expr`} とします。
        書き換えの式全体は\type(Unit);型です。引き続き処理を行なうには
        逐次評価の二項演算子 \mcrd-type(`before`)(Func(Unit, Func(Bound`a`, Bound`a`)));を用います。
        例えば
        
        \mcrd-input`ref1.mcrds` ```
          let-mutable x <- {hoge} in
            (! x) ^ {/} ^ ( x <- {piyo} before (! x) )
        ```
        
        に対する出力は
        
        \mcrd-output`ref1.txt` ```
          hoge/piyo
        ```
        
        となります。
      }
      \p{
        ループの機能もあります。\mcrd`while` を用いて
        
        \code-display{
          \synt`while` \meta`ExprB` \synt`do` \meta`ExprC`
        }
        
        と書くと，\code{\meta`ExprB`} が真である間 \code{\meta`ExprC`} を繰り返し評価し，
        \code{\meta`ExprB`} が偽となった時に\type(Unit);型の唯一の値を返します。
        これを用いると，例えば\math{1}から\math{n}までの和を求める函数は
        
        \mcrd-input`while.mcrds` ```
          let sum n =
            let-mutable i <- 1 in
            let-mutable r <- 0 in
              ( while ! i <= n do
                r <- (! r) + (! i) before i <- (! i) + 1
              ) before ! r

          in arabic (sum 10)
        ```
        \mcrd-output`while.txt` ```
          55
        ```
        
        と定義して使うことができます。しかしこの例のような処理は“わざわざ”手続き的に書かなくとも
        
        \mcrd-input`rec.mcrds` ```
          let sum n =
            if n <= 0 then 0 else n + (sum (n - 1))
          
          in arabic (sum 10)
        ```
        
        とすれば済む話ではあります。
        手続き的処理がどうしても必要な場面というのは，
        例えば文書の冒頭で宣言的に書かれた情報を文書の途中で使うために書き換え可能変数に保持しておくといった，
        比較的限定された状況なのです。
      }
    }
    \subsection{モジュール機能}{
      \p{
        \version;から導入された機能です。
        
        \code-display{
          \synt`module` \meta`Mod` \synt`=` \synt`struct`\code-break;
          \code-tab;\metadots;\code-break;
          \synt`end-struct`
        }
        
        でモジュール\code{\meta`Mod`}を宣言し，\code{\metadots;}にそのモジュールに属する函数などを記述します。
        モジュールの外で\code{\meta`Mod`\synt`.`\meta`f`}という名前で使えるようにしたい函数\code{\meta`f`}は
        
        \code-display{
          \synt`publ` \synt`let` \meta`f` \meta`x1` \metadots; \meta`xn` \synt`=` \meta`Expr`
        }
        
        のように先頭に\code{\synt`publ`}をつけて，一方
        外から見えずモジュール内でしか使えないようにしたい函数\code{\meta`g`}は
        
        \code-display{
          \synt`priv` \synt`let` \meta`g` \meta`x1` \metadots; \meta`xn` \synt`=` \meta`Expr`
        }
        
        のように\code{\synt`priv`}をつけて定義します。並列定義も可能で，
        
        \code-display{
          \synt`priv` \synt`let` \meta`f` \meta`x1` \metadots; \meta`xn` \synt`=` \meta`ExprA`\code-break;
          \code-tabx(5);\synt`and` \meta`g` \meta`y1` \metadots; \meta`ym` \synt`=` \meta`ExprB`
        }
        
        とすることができます。この場合\code{\meta`f`}と\code{\meta`g`}は共にモジュール内でしか使えない函数になります。
        上の例で\code{\meta`f`}だけモジュール外で使いたい場合は，
        
        \code-display{
          \synt`priv` \synt`let` \meta`f` \meta`x1` \metadots; \meta`xn` \synt`=` \meta`ExprA`\code-break;
          \code-tabx(5);\synt`and` \meta`g` \meta`y1` \metadots; \meta`ym` \synt`=` \meta`ExprB`\code-break;
          \synt`publ` \synt`let` \meta`h` \synt`=` \meta`f`
        }
        
        などとすることで\code{\meta`Mod`\synt`.`\meta`h`}が使えます。
      }
      \p{
        ただし，\code{\synt`publ`}と\code{\synt`priv`}のうち
        \code{\synt`publ`}の方は制御綴の定義には使えず，構文解析の段階でエラーを返します。
        これは\code{\meta`Mod`\synt`.\`\meta`cs`}や\code{\synt`\`\meta`Mod`\synt`.`\meta`cs`}のような
        使い勝手の悪い制御綴を避けることを意図しています。
        代わりに制御綴の定義にのみ使える\code{\synt`direct`}を用いて
        
        \code-display{
          \synt`direct` \synt`let` \synt`\`\meta`cs` \meta`x1` \metadots; \meta`xn` \synt`=` \meta`Expr`
        }
        
        と定義することで，モジュールの外で\code{\synt`\`\meta`cs`}が
        \code{\meta`Mod`}をつけずにそのまま使えるようになります。
        裏を返せば，大域環境から見える制御綴は名前空間を分けられないようになっているので，
        モジュール内外や別のモジュール間でも重複しうることを念頭に置いて使用してください。
      }
      \p{
        モジュールの使用例を掲げます。
        
        \mcrd-input`module01.mcrds` ```
          module Display = struct
            priv let punct-sub lst =
              match lst with
              | []           -> {}
              | head :: []   -> head
              | head :: tail -> let tailstr = punct-sub tail in {@head;, @tailstr;}

            publ let punct lst = let inner =punct-sub lst in {[@inner;]}
          end-struct

          in
            Display.punct {|hoge|piyo|fuga|moge|}
        ```
        
        \mcrd-output`module01.txt` ```
          [hoge, piyo, fuga, moge]
        ```
        
        \mcrd`punct-sub` はモジュール内でしか使えないように \mcrd`priv` が指定されており，
        \mcrd`Display.punct` の箇所を \mcrd`Display.punct-sub` に変更すると
        
        \mcrd-display```
          ! [ERROR AT TYPECHECKER] at line 12, characters 2-19:
              undefined variable 'Display.punct-sub'.
        ```
        
        と未定義によるエラーが返されます。
      }
    }
    \subsection{最終値参照と大域ハッシュ}{
      \p{
        \newword{最終値参照}は，出力する文字列をそれよりも後方の情報に依存して決めたい，
        ということを実現するのに便利な機能です。が，慎重に使わないと理解が困難になる危険な機能でもあります。
        次節：\type(String);型の実体と2段階評価も合わせてお読みになることを強く推奨します。
      }
      \p{
        出力する文字列をそれよりも後方の情報に依存して決めたいなどという状況は想像がつきにくいかもしれませんが，
        簡潔な例だと前方で後方の章節番号を参照するときなどです。
        
        節の番号をidから参照することを意図し，
        
        \mcrd-input`ref1.mcrdh` ```
          let-mutable secnum <- 0
          let-mutable reflist <- []
          let \section head body =
            secnum <- (! secnum) + 1 before
            ( if-id-is-valid reflist <- (id, (! secnum)) :: (! reflist) else () ) before
            ( let numstr = (arabic (! secnum)) in {
              <h1>@numstr;. @head;</h1>\deeper{
                @body;
              }<!-- -->
            } )

          let find lst key =
            match lst with
            | []                             -> {??}
            | (k, v) :: tail when same k key -> arabic v
            | _ :: tail                      -> find tail key
          
          let \ref key = find (! reflist) key
        ```
        
        という具合にヘッダファイルを実装すると
        
        \mcrd-input`doc.mcrd` ```
          \section #first {はじめに}{
            あー
          }
          \section{間にある節}{
            いー
          }
          \section{引用のテスト}{
            うー
            第\ref{first}節に戻る
            第\ref{latter}節には行けない
          }
          \section #latter {後ろの節}{
            えー
          }
        ```
        
        という入力に対して
        
        \mcrd-output`doc.txt` ```
          <h1>1. はじめに</h1>
            あー
          <!-- -->
          <h1>2. 間にある節</h1>
            いー
          <!-- -->
          <h1>3. 引用のテスト</h1>
            うー
            第1節に戻る
            第??節には行けない
          <!-- -->
          <h1>4. 後ろの節</h1>
            えー
          <!-- -->
        ```
        
        と出力が得られるのですが，見ての通り\mcrd`\ref`を書いたところよりも後方にある番号は参照できず，
        \mcrd`find`の定義内に見つからなかった時のためのダミーとして書いておいた\mcrd`??`が出力されています。
        これは\mcrd`\section #latter {後ろの節}{えー}`が評価されるまで変数\mcrd`reflist`に
        \mcrd`({latter}, {4})`が格納されないためです。
        \LaTeX;ではこのような参照について「1回目の処理で参照情報を外部ファイル\file-name{….aux}に書き出しておき，
        複数回実行することで整合させる」という方針をとっていますが，
        Macrodownではこのような状況でも不正な出力があることを避けたい，むやみにファイル入出力しないようにしたい，
        という動機のもとで1回の評価での後方参照が可能な機能を設けました。
      }
      \p{
        具体的な仕組みはというと，上のナイーヴな参照機能の実装で用いた\mcrd`reflist`という参照リストに相当する機能を
        \newword{大域ハッシュ}という形にしています。
        大域ハッシュそのものは最初から備わっており，ユーザは\newword{キー}とそれに対応する内容を宣言します。
        \type(String);型のキー\code{\meta`k`}と\type(String);型の内容\code{\meta`v`}に対し，
        
        \code-display{
          \synt`new-global-hash` \meta`k` \synt`<<-` \meta`v`
        }
        
        でキーと内容の対応 (\code{\meta`k`}, \code{\meta`v`}) を大域ハッシュに入れます。
        この式は常に\mcrd`()`を返し，\type(Unit);型です。
        実際にキー\code{\meta`k`}に対応する内容\code{\meta`v`}を出力したい箇所で
        
        \code-display{
          \synt`!!` \meta`k`
        }
        
        と書くと，最終出力段階までに\code{\meta`k`}に対応する内容の文字列\code{\meta`v`}が大域ハッシュに入っていれば
        \code{\synt`!!` \meta`k`}の箇所が\code{\meta`v`}に置き換わって出力されます。
        \code{\code`!!` \meta`k`}より後ろでもかまわないので，
        とにかく対応 (\code{\meta`k`}, \code{\meta`v`}) が最終出力段階までに登録されていればよいのです。
        最終出力段階については次節で述べるとして，まずは小さい例を見てみましょう。
        
        \mcrd-input`global-hash.mcrds` ```
          let enclose1 x = {[@x;]}
          let enclose2 x = {<@x;>}
          in
            (enclose1 (!! {key1})) ^ break ^
              (new-global-hash {key1} <<- {CONTENT} before {<} ^ (!! {key1}) ^ {>} )
        ```
        
        これを実行すると

        \mcrd-output`global-hash.txt` ```
          [CONTENT]
          <CONTENT>
        ```
        
        という出力が得られ，確かにキーと内容の対応を入れる前に書かれている\mcrd`!! {key1}`に対しても
        文字列\mcrd`CONTENT`が出力されていることがわかります。先ほどのヘッダファイルも
        
        \mcrd-input`ref2.mcrdh` ```
          let-mutable secnum <- 0
          let-mutable reflist <- []
          let \section head body =
            secnum <- (! secnum) + 1 before
            ( if-id-is-valid new-global-hash id <<- arabic (! secnum) else () ) before
            ( let numstr = (arabic (! secnum)) in {
              <h1>@numstr;. @head;</h1>\deeper{
                @body;
              }<!-- -->
            } )
          
          let \ref key = !! key
        ```
        
        と代替すると，
        
        \mcrd-output`doc.txt` ```
          <h1>1. はじめに</h1>
            あー
          <!-- -->
          <h1>2. 間にある節</h1>
            いー
          <!-- -->
          <h1>3. 引用のテスト</h1>
            うー
            第1節に戻る
            第4節は引用できない
          <!-- -->
          <h1>4. 後ろの節</h1>
            えー
          <!-- -->
        ```
        
        のように後方への参照もうまく出力されます。
      }
      \p{
        なお，最終出力段階まで未定義のキーが\mcrd`!!`で参照されていた場合，
        これは未定義のキーであるとしてエラーになります。例えば
        
        \mcrd-input`key-error.mcrds` ```
          let enclose s = {[@s;]} in enclose (!! {key0})
        ```
        
        を処理すると，最終出力段階で
        
        \mcrd-display```
          ! [ERROR AT OUTPUT] undefined reference key "key0".
        ```
        
        という具合にエラーが返されます。
      }
    }
    \subsection{\type(String);型の実体と2段階評価}{
      \p{
        最初に衝撃の事実ですが\type(String);型の値は文字列ではありません。
        \type(String);型の値は文字列に限らず，インデントの階層を保持した構造\code{\synt`\deeper` \meta`s`}\footnote{
          正確には抽象構文木なので，\mcrd`\deeper`というトークンがそのまま保持されているわけではありません。
        }，大域ハッシュのキーによる参照\code{\synt`!!` \meta`k`}などの情報を持っています。
        これらの値を筋よく扱うため，Macrodownの評価の仕組みは\newword{第1段階評価}と\newword{第2段階評価}に分けられており，
        第1段階評価がすべて終わって第2段階評価のみが行なわれている状態を\newword{最終出力段階}と呼びます。
        インデントの階層と最終値参照のキーは第1段階評価では評価されることなく残り，
        第2段階評価に移行してはじめて評価が始まります。
        こうして第2段階評価によってすべての情報が文字列化されてはじめてテキストファイルに出力されるのです。
      }
      \p{
        第2段階評価では，インデント量の決定が\mcrd`\deeper`のつくる構造をもとに行なわれ，
        また同時に最終値参照のキーを内容に置き換える処理がなされています。
        つまり，第2段階評価になるまではどんな文字列がテキストファイルに書き出されるかは確定していないということになります。
        一方，\mcrd`string-sub`，\mcrd`string-length`，\mcrd`same`などは
        “実際に文字列そのものを見て評価される必要がある”プリミティヴでした。
        このような函数の適用を第1段階評価の範疇で評価することは原理的に不可能なはずですが，
        実際にこれまでの例で\mcrd`string-sub`，\mcrd`string-length`，\mcrd`same`は意図通り動いていました。
        ではどのように評価しているかというと，
        実はこれらの“実際に文字列そのものを見て評価される必要がある”プリミティヴの適用を評価するときは
        例外的に第2段階評価を施しているのです。
        したがって，最終出力段階に至っていない時でも第2段階評価は細かく行なわれうるということです。
      }
      \p{
        これまでに登場した例では，インデント構造や最終値参照を含んでいない値だけを
        これらの文字列操作プリミティヴに渡していたため問題なく動作していた，ということです。
        したがって，インデント構造や最終値参照が残っている\type(String);型の値をこれらのプリミティヴに渡してしまうと，
        かなり予想困難な挙動をする可能性も十分あります。例えば
        
        \mcrd-input`sub-value.mcrds` ```
          let r = !! `mcrd` in
            (string-sub r 0 3) ^ {/} ^ (new-global-hash `mcrd` <<- {Macrodown} before !! `mcrd`)
        ```
        
        という入力に対しては\mcrd`Mac/Macrodown`と出力されることが直感的に期待できそうですが，
        実際はそうではなく，

        \mcrd-display```
          ! [ERROR AT EVALUATOR] illegal argument for 'string-sub': undefined reference key "mcrd".
        ```
        
        とエラーを返されます。これは\mcrd`string-sub`に対して\mcrd``!! `mcrd` ``が適用され，
        ここで第2段階評価が行なわれた結果，キー\mcrd`mcrd`に対応する内容が未登録だったためです。
      }
      \p{
        文字列操作プリミティヴだけでなく，
        \type(String);型のパターンマッチでも文字列の内容が一致しているかどうかを見るために
        \mcrd`same`と同等の方法で比較をしています。
        このほか，大域ハッシュへの登録に使うキーと内容そのものも\type(String);型であり，
        やはり第2段階評価を行なってから大域ハッシュに入れています。
        したがって，次のような例は最終出力段階で無限ループに陥るはずです。
        
        \mcrd-input`infinite.mcrds` ```
          let r = !! {key} in
            new-global-hash {key} <<- r before r
        ```
      }
      \p{
        いずれにしても，最終値参照を含む値や，改行を含んでいてインデントになる部分があるような値を文字列操作プリミティヴに渡すことは
        できるだけ避けるように心がけ，意図的に行なう場合でも細心の注意を払うようにしてください。
      }
    }
  }
  \section{字句解析の厳密な仕様}{
    \subsection{概要}{
      \p{
        この章は，Macrodownのより詳細で厳密な仕様が気になるという方に向けた記述です。
        Macrodownは大きく分けて
        \itemize{
          * テキスト階層
          * プログラム階層
          * アクティヴ階層
          * リテラル階層
          * コメント階層
        }
        を行き来しながらソースコードをトークンとして解釈します。
        文書（拡張子が\extension{.mcrd}のもの）はテキスト階層で読み込みが開始され，一方で
        ヘッダ（拡張子が\extension{.mcrdh}のもの）はプログラム階層で読み込みが開始されます。
      }
    }
    \subsection{テキスト階層}{
      \p{
        マクロではなく文書そのものを書いているときは，
        このテキスト階層を中心に意識していれば良いでしょう。
      }
      \p{
        大小ラテン文字とアラビア数字とハイフンを\newword{基本文字}，その他の文字を\newword{非基本文字}，
        基本文字のみからなり先頭が大小ラテン文字である文字列を\newword{名前文字列}と呼ぶことにすると，
        テキスト階層では文字列を\ref{token-text}に示す規則でマッチするようにトークン化します。
        ただし + は1回以上の繰り返しを表し，また複数通りのマッチがある場合はより長い文字列ほど優先し，
        同一の文字列が複数のトークンにマッチする場合は表で上位に掲げられているものほど優先されます。
      }
      \float-table #token-text {テキスト階層で認識されるトークンとその規則}{
        \description{
          |\d-item{\mcrd`\`（名前文字列）}{\math{\token-cs;}：\newword{制御綴トークン}}
          |\d-item{\mcrd`@`}{\math{\token-varinstr;}：\newword{文字列中変数参照トークン}}
          |\d-item{\mcrd`{`}{\math{\token-bgrp;}：\newword{ブロック開始トークン}}
          |\d-item{\mcrd`}`}{\math{\token-egrp;}：\newword{ブロック終了トークン}・\newword{テキスト終了トークン}}
          |\d-item{\mcrd`|`}{\math{\token-sep;}：\newword{区切りトークン}}
          |\d-item{\mcrd`\`（非基本文字）}{\math{\token-char;}：エスケープされた\newword{文字トークン}}
          |\d-item{\mcrd`` ` ``+}{\math{\token-opnqt;}：\newword{リテラル開始トークン}}
          |\d-item{\mcrd`%`}{\newword{コメント開始トークン}}
          |\d-item{（空白文字）または（タブ文字）}{\math{\token-space;}}：\newword{空白トークン}
          |\d-item{（改行文字）}{\math{\token-break;}}：\newword{改行トークン}
          |\d-item{（1文字）}{\math{\token-char;}：\newword{文字トークン}}
          |}
      }
      \p{
        表からわかるように，
        \mcrd`%`，\mcrd`\`，\mcrd`@`，\mcrd`{`，\mcrd`}`，\mcrd`|`，\mcrd`` ` ``
        はそのまま書くことができず，\mcrd`\` を手前につけてエスケープしなければならない文字です。
      }
      \p{
        ただし，空白文字，タブ文字，改行文字をまとめて\newword{空白類文字}と呼ぶことにすると，
        \itemize{
          * 行頭の空白類文字
          * 空白類文字の直後の空白類文字
          * \mcrd`{` の直後の空白類文字
          * \mcrd`}` の手前に連続して並んでいる空白類文字
        }
        はいずれも空白トークンおよび改行トークンと認識されることなく読み捨てられます。
        したがって \mcrd`{` の直後での改行やインデントなどを比較的自由に入れることができます。
      }
      \p{
        また制御綴トークンと変数名トークンは，認識されると直後に字句解析器がアクティヴ階層に遷移します。
        同様に，リテラル開始トークンが認識されると直後にリテラル階層に，
        コメント開始トークンが認識されるとこのコメント開始トークンは即座に読み捨てられてコメント階層に遷移します。
        その他のトークンを認識した直後はテキスト階層を維持して次のトークンの認識に移ります。
      }
      \p{
        \mcrd`}` は基本的に\newword{ブロック終了トークン} \math{\token-egrp;} ですが，
        場合によっては\newword{テキスト終了トークン} \math{\token-clsstr;} となります。
        プログラム階層で後述しますが，
        プログラム階層からテキスト階層に入るときに
        \newword{テキスト開始トークン} \math{\token-opnstr;} と扱われた \mcrd`{` と釣り合う \mcrd`}` は
        テキスト終了トークン \math{\token-clsstr;} となり，これが認識されるとテキスト階層を出てプログラム階層に戻ります。
      }
    }
    \subsection{プログラム階層}{
      \p{
        プログラム階層は，\newword{マクロ}や\newword{函数}の定義に用います。
        プログラム階層で認識されるトークンとその規則を\ref{token-program}に示します。
        全体的にML風の構文をとっています。
      }
      \float-table #token-program {プログラム階層で認識されるトークン}{
        \description{
          | \d-item{\mcrd`(`}{
              \math{\token-lparen;}：\newword{開括弧トークン}}
          | \d-item{\mcrd`)`}{
              \math{\token-rparen;}：\newword{閉括弧トークン}・%
              \math{\token-clsprog;}：\newword{プログラム終了トークン}}
          | \d-item{\mcrd`[`}{
              \math{\token-blist;}：\newword{リスト開括弧トークン}}
          | \d-item{\mcrd`]`}{
              \math{\token-elist;}：\newword{リスト閉括弧トークン}}
          | \d-item{\mcrd`;`}{
              \math{\token-listpunct;}：\newword{リスト区切りトークン}}
          | \d-item{（二項演算子）}{
              \math{\token-bin;}：\newword{二項演算子トークン}}
          | \d-item{\mcrd`let`}{
              \math{\token-let;}：\newword{宣言トークン}}
          | \d-item{\mcrd`and`}{
              \math{\token-and;}：\newword{並列宣言トークン}}
          | \d-item{\mcrd`in`}{
              \math{\token-in;}：\newword{inトークン}}
          | \d-item{\mcrd`if`}{
              \math{\token-if;}：\newword{ifトークン}}
          | \d-item{\mcrd`then`}{
              \math{\token-then;}：\newword{thenトークン}}
          | \d-item{\mcrd`else`}{
              \math{\token-else;}：\newword{elseトークン}}
          | \d-item{\mcrd`true`}{
              \math{\token-true;}：\newword{真トークン}}
          | \d-item{\mcrd`false`}{
              \math{\token-true;}：\newword{偽トークン}}
          | \d-item{\mcrd`function`}{
              \math{\token-function;}：\newword{無名函数トークン}}
          | \d-item{\mcrd`->`}{
              \math{\token-arrow;}：\newword{無名函数矢印トークン}}
          | \d-item{\mcrd`if-class-is-valid`}{
              \math{\token-if-class-is-valid;}：\newword{if-class-is-validトークン}}
          | \d-item{\mcrd`if-id-is-valid`}{
              \math{\token-if-id-is-valid;}：\newword{if-id-is-validトークン}}
          | \d-item{\mcrd`let-mutable`}{
              \math{\token-let-mutable;}：\newword{変更可能変数宣言トークン}}
          | \d-item{\mcrd`<-`}{
              \math{\token-oweq;}：\newword{破壊的代入トークン}}
          | \d-item{\mcrd`before`}{
              \math{\token-before;}：\newword{逐次評価トークン}}
          | \d-item{\mcrd`()`}{
              \math{\token-unit;}：\newword{ユニットトークン}}
          | \d-item{\mcrd`while`}{
              \math{\token-while;}：\newword{whileトークン}}
          | \d-item{\mcrd`do`}{
              \math{\token-do;}：\newword{doトークン}}
          | \d-item{\mcrd`new-global-hash`}{
              \math{\token-new-global-hash;}：\newword{ハッシュ宣言トークン}}
          | \d-item{\mcrd`renew-global-hash`}{
              \math{\token-renew-global-hash;}：\newword{ハッシュ変更トークン}}
          | \d-item{\mcrd`<<-`}{
              \math{\token-owhash;}：\newword{ハッシュ代入トークン}}
          | \d-item{（名前文字列）}{
              \math{\token-ident;}：\newword{項トークン}}
          | \d-item{（整数文字列）}{
              \math{\token-int;}：\newword{整数トークン}}
          | \d-item{\mcrd`{`}{
              \math{\token-opnstr;}：\newword{テキスト開始トークン}}
          | \d-item{\mcrd`` ` ``}{
              \math{\token-opnqt;}：\newword{リテラル開始トークン}}
          | \d-item{\mcrd`%`}{\newword{コメント開始トークン}}
          |}
      }
      \p{
        \mcrd`{` を見つけてテキスト開始トークン \math{\token-opnstr;} と認識すると，直後にテキスト階層に入ります。
        テキスト階層で釣り合う \mcrd`}` を見つけると，それをテキスト終了トークン \math{\token-clsstr;} とみなして
        再びプログラム階層に戻ってきます。
      }
      \p{
        \mcrd`)` は基本的に\newword{閉括弧トークン} \math{\token-rparen;} となりますが，
        アクティヴ階層で \mcrd`(` をプログラム開始トークン \math{\token-opnprog;} と認識してプログラム階層に入ってきていたとき，
        釣り合う \mcrd`)` を\newword{プログラム終了トークン} \math{\token-clsprog;} と認識し，直後にアクティヴ階層に戻ります。
      }
      \p{
        finishトークン \math{\token-finish;} はヘッダファイルを終了させるトークンで，
        ユーザーは入力できず，大域環境の末尾に自動的に附加されます。
        これが評価されたときの環境が次のファイルの読み込みに引き継がれます。
      }
    }
    \subsection{アクティヴ階層}{
      \p{
        アクティヴ階層は，
        テキスト階層内で制御綴トークンと変数名トークン直後にのみ現れる，
        テキスト階層から出ることなく整数値などを扱うための例外的な部分です。
        とは言いつつも文書中で直接プログラムを書くということは普通避けたいので，
        実際には整数値をマクロに引数として渡すなど短い記述で完結することがほとんどです。
        トークンの認識規則を\ref{token-active}に示します。
      }
      \float-table #token-active {アクティヴ階層で認識されるトークンとその規則}{
        \description{
          | \d-item{\mcrd`(`}{
              \math{\token-opnprog;}：\newword{プログラム開始トークン}}
          | \d-item{\mcrd`#`（名前文字列）}{
              \math{\token-id;}：\newword{ID名トークン}}
          | \d-item{\mcrd`.`（名前文字列）}{
              \math{\token-class;}：\newword{クラス名トークン}}
          | \d-item{\mcrd`{`}{
              \math{\token-bgrp;}：\newword{ブロック開始トークン}}
          | \d-item{\mcrd`` ` ``}{
              \math{\token-opnqt;}：\newword{リテラル開始トークン}}
          |}
      }
      \p{
        \mcrd`(` を読んでプログラム開始トークン \math{\token-opnprog;} を認識すると，直後にプログラム階層に入ります。
        プログラム階層内で釣り合う \mcrd`)` を読むと，これをプログラム終了トークン \math{\token-clsprog;} と認識して
        直後にアクティヴ階層に戻ってきます。
        これにより制御綴の引数として文字列だけでなく整数値などを扱うことができるようになっています。
      }
      \p{
        \mcrd`{` を読んでブロック開始トークン \math{\token-bgrp;} を認識すると，直後にアクティヴ階層を出てテキスト階層に戻ります。
        同様にリテラル開始トークン \math{\token-opnqt;} を認識すると
        直後にアクティヴ階層を出てさらに即座にリテラル階層に入り，
        リテラル階層を出るとテキスト階層に戻ります。
        つまり，アクティヴ階層は最初に現れる \mcrd`{` か \mcrd`` ` `` の直前で終了するということになります。
      }
    }
    \subsection{リテラル階層}{
      \p{
        リテラル階層は書いた文字列をそのまま出力するための特殊なブロックです。
        \mcrd`` ` `` が\math{n}個連なる文字列をそのまま出したい場合，\math{n + 1} 個以上で左右同数の
        \mcrd`` ` `` で括るとリテラル階層となります。
        したがって，リテラル階層は入ってきたときのリテラル開始トークンと同じ個数の
        連続した \mcrd`` ` `` を認識するともともといた階層に戻る，という動作をします。
        「文字列をそのまま出力する」と言いつつも，
        インデントは空白文字でも改行文字でもない文字を含む最もインデントの浅い行に合わせて削られ，
        さらに先頭の空白文字が0文字以上連続した部分および
        末尾の改行文字1文字以下と空白文字0文字以上が連続した部分は削除されるので注意してください。
      }
    }
    \subsection{コメント階層}{
      \p{
        コメント階層では，改行文字が現れるまで全ての文字を読み飛ばします。
        そして改行文字を認識すると，
        その改行文字も含めてそこまでがコメントだったとしてコメント階層を離れ，
        入る前にいたもとの階層に戻ります。
        特にテキスト階層からコメント階層に入ってきて再びテキスト階層に戻るとき，
        改行文字は出力されず，
        さらにコメント階層から抜けた直後は行頭なので空白類文字が無視されることに注意してください。
      }
    }
  }
  \section{構文解析の厳密な仕様}{
    \p{
      Macrodownは字句解析が終了した後に構文解析に移ります。
      文法は以下のBNFで表されます。
      拡張子が\extension{.mcrd}である文書は \math{\Text;} で表現される文字列を，
      拡張子が\extension{.mcrdh}であるヘッダおよび拡張子が\extension{.mcrds}である単独ファイルは
      \math{\TopLevel;} で表現される文字列を
      それぞれ受理します。ただし，結合順序は適切に定まっているものとします。
      \math-dp-gather{
        | \cfl{\TopLevel;}{|  \repeat-plus{\TopSingle;} \cfl-or{|\token-in; \Expr; | \epsilon; |} |}
        | \cfl{\TopSingle;}{
            | \token-let; \Dec; \repeat-star{\token-and; \Dec;}
            | \token-mutual; \repeat-plus{\token-let; \Dec;} \token-end-mutual;
            |}
        | \cfl{\Expr;}{
            | \token-let; \Dec; \repeat-star{\token-and; \Dec;} \token-in; \Expr;
            |!br
            | \token-if; \Expr; \token-then; \Expr; \token-else; \Expr;
            |!br
            | \token-function; \Args; \token-arrow; \Expr;
            |!br
            | \Expr; \token-bin; \Expr; | \Expr; \Expr;
            | \token-ident;
            | \token-lparen; \Expr; \token-rparen;
            |!br
            | \GroupInExpr; | \token-int; | \token-true; | \token-false; | \token-unit; | \token-finish;
            |!br
            | \token-let-mutable; \token-ident; \token-oweq; \Expr; \token-in; \Expr;
            | \token-ident; \token-oweq; \Expr;
            |!br
            | \token-while; \Expr; \token-do; \Expr;
            | \Expr; \token-before; \Expr;
            |!br
            | \token-if-class-is-valid; \cfl-or{|\epsilon;|\token-then;|} \Expr; \token-else; \Expr;
            |!br
            | \token-if-id-is-valid; \cfl-or{|\epsilon;|\token-then;|} \Expr; \token-else; \Expr;
            |!br
            | \token-new-global-hash; \Expr; \token-owhash; \Expr;
            |!br
            | \token-renew-global-hash; \Expr; \token-owhash; \Expr;
            |}
        | \cfl{\Dec;}{| \cfl-or{|\token-ident;|\token-cs;|} \Args; \token-defeq; \Expr; |}
        | \cfl{\Args;}{| \repeat-star{\token-ident;} |}
        | \cfl{\Text;}{| \repeat-star{\Single;} |}
        | \cfl{\Single;}{
            | \token-char; | \token-space; | \token-break;
            | \token-varinstr; \token-ident; \token-end;
            |!br
            | \token-cs; \cfl-or{| \epsilon; | \token-class; |} \cfl-or{| \epsilon; | \token-id; |} \ExprArgs; \TextArgs;
            |}
        | \cfl{\ExprArgs;}{| \repeat-star{\token-opnprog; \Expr; \token-clsprog;} |}
        | \cfl{\TextArgs;}{| \token-end; | \repeat-plus{ \GroupInText; } |}
        | \cfl{\GroupInText;}{| \token-bgrp; \Text; \token-egrp; | \token-opnqt; \Literal; \token-clsqt; |}
        | \cfl{\GroupInExpr;}{| \token-opnstr; \Text; \token-clsstr; | \token-opnqt; \Literal; \token-clsqt; |}
        |}
    }
  }
}
